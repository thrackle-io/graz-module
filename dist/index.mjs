import{GasPrice as Pe}from"@cosmjs/stargate";import Be from"zustand";import{persist as qe,subscribeWithSelector as Ue}from"zustand/middleware";var P=(n=>(n.KEPLR="keplr",n.LEAP="leap",n))(P||{}),O=["keplr","leap"];var w={account:null,activeChain:null,balances:null,clients:null,defaultChain:null,defaultSigningClient:"stargate",offlineSigner:null,offlineSignerAmino:null,offlineSignerAuto:null,recentChain:null,signingClients:null,status:"disconnected",walletType:"keplr",_notFoundFn:()=>null,_reconnect:!1},Re={name:"graz",partialize:e=>({activeChain:e.activeChain,recentChain:e.recentChain,_reconnect:e._reconnect}),version:1},a=Be(Ue(qe(()=>w,Re)));import{SigningCosmWasmClient as F}from"@cosmjs/cosmwasm-stargate";import{SigningStargateClient as N}from"@cosmjs/stargate";import{Tendermint34Client as Me}from"@cosmjs/tendermint-rpc";import{QueryClient as Ge}from"@cosmjs/stargate";import{assert as z,isNonNullObject as W}from"@cosmjs/utils";var _=(...e)=>{let{tendermint:t}=a.getState().clients,n=new Ge(t),r=e.map(s=>s(n));for(let s of r){z(W(s),"Extension must be a non-null object");for(let[o,i]of Object.entries(s)){z(W(i),`Module must be a non-null object. Found type ${typeof i} for module "${o}".`);let u=n[o]||{};n[o]={...u,...i}}}return n};var x=async({rpc:e,rpcHeaders:t})=>{let n={url:e,headers:{...t||{}}},[r,s,o]=await Promise.all([F.connect(n),N.connect(n),Me.connect(n)]);return{cosmWasm:r,stargate:s,tendermint:o}},h=async e=>{let{rpc:t,rpcHeaders:n,offlineSignerAuto:r,cosmWasmSignerOptions:s={},stargateSignerOptions:o={}}=e,i={url:t,headers:{...n||{}}},[u,p]=await Promise.all([F.connectWithSigner(i,r,s),N.connectWithSigner(i,r,o)]);return{cosmWasm:u,stargate:p}};var D=(e=a.getState().walletType)=>{try{return y(e),!0}catch(t){return console.error(t),!1}},Ke=()=>{if(typeof window.keplr<"u")return window.keplr;throw a.getState()._notFoundFn(),new Error("window.keplr is not defined")},Qe=()=>{if(typeof window.leap<"u")return window.leap;throw a.getState()._notFoundFn(),new Error("window.leap is not defined")},y=(e=a.getState().walletType)=>{switch(e){case"keplr":return Ke();case"leap":return Qe();default:throw new Error("Unknown wallet type")}},Yt=()=>Object.fromEntries(O.map(e=>[e,D(e)]));var C=async e=>{try{let{defaultChain:t,recentChain:n,walletType:r}=a.getState(),s=(e==null?void 0:e.walletType)||r,o=y(s),i=e||n||t;if(!i)throw new Error("No last known connected chain, connect action requires chain info");a.setState(b=>{let ve=b._reconnect;return b.activeChain&&b.activeChain.chainId!==i.chainId?{status:"connecting"}:ve?{status:"reconnecting"}:{status:"connecting"}}),await o.enable(i.chainId);let u=o.getOfflineSigner(i.chainId),p=o.getOfflineSignerOnlyAmino(i.chainId),m=await o.getOfflineSignerAuto(i.chainId),l=i.gas?Pe.fromString(`${i.gas.price}${i.gas.denom}`):void 0,[Q,Te,ke]=await Promise.all([o.getKey(i.chainId),x(i),h({...i,offlineSignerAuto:m,cosmWasmSignerOptions:{gasPrice:l,...(e==null?void 0:e.signerOpts)||{}}})]);return a.setState({account:Q,activeChain:i,clients:Te,offlineSigner:u,offlineSignerAmino:p,offlineSignerAuto:m,recentChain:i,signingClients:ke,status:"connected",walletType:s,_reconnect:!0}),Q}catch(t){throw a.getState().account===null&&a.setState({status:"disconnected"}),t}},H=async(e=!1)=>(a.setState(t=>({...w,recentChain:e?null:t.recentChain})),Promise.resolve()),d=()=>{let{activeChain:e}=a.getState();e&&C(e)};var L=()=>{a.setState({recentChain:null})},V=e=>{let{activeChain:t}=a.getState();return t==null?void 0:t.currencies.find(n=>n.coinMinimalDenom===e)},on=()=>a.getState().recentChain,j=async e=>(await y().experimentalSuggestChain(e),e),Y=async({chainInfo:e,...t})=>{let n=await j(e);return{account:await C({chainId:e.chainId,currencies:e.currencies,rest:e.rest,rpc:e.rpc,...t}),chain:n}};var J=(e={})=>(a.setState(t=>({defaultChain:e.defaultChain||t.defaultChain,defaultSigningClient:e.defaultSigningClient||t.defaultSigningClient,walletType:e.defaultWallet||t.walletType,_notFoundFn:e.onNotFound||t._notFoundFn})),e);import{bech32 as Oe}from"bech32";import{resolveDomainDetails as ze,resolveDomainIntoAddresses as We,resolveDomainIntoChainAddress as _e,resolvePrimaryDomainByAddress as Fe}from"ibc-domains-sdk";var Ne=e=>e.endsWith(".cosmos"),He=(e,t)=>{if(!e)return!1;try{return Oe.decode(e).prefix===t}catch{return!1}},$=async(e,t)=>{let n=await Fe(e,t);if(n.error)throw new Error(n.error);if(n.value===null)return null;let r=n.value;return{domain:r.domain,domainFull:r.domain_full}},X=async(e,t)=>{let n=await We(e,t);if(n.error)throw new Error(n.error);return n.value===null?null:n.value},I=async(e,t,n)=>{let r=await _e(e,t,n);if(r.error)throw new Error(r.error);return r.value===null?null:r.value},Z=async(e,t)=>{let n=await ze(e,t);if(n.error)throw new Error(n.error);return n.value===null?null:n.value},ee=async({value:e,prefix:t,isTestnet:n})=>{if(e.trim()==="")throw new Error("value can't be an empty string");if(Ne(e)){let o=await I(e,t,n);if(!o)throw new Error("ibc domain not found");return o}if(!He(e,t))throw new Error("Address is not valid");return e};var te=async e=>{let{activeChain:t,signingClients:n}=a.getState();if(!t||!n)throw new Error("No connected account detected");let{defaultSigningClient:r}=a.getState();return await Promise.all(t.currencies.map(async o=>n[r].getBalance(e,o.coinMinimalDenom)))},ne=async e=>{let{clients:t}=a.getState();if(!(t!=null&&t.stargate))throw new Error("Stargate client is not ready");return t.stargate.getBalanceStaked(e)},se=async({senderAddress:e,recipientAddress:t,amount:n,fee:r,memo:s})=>{let{signingClients:o,defaultSigningClient:i}=a.getState();if(!o)throw new Error("No connected account detected");if(!e)throw new Error("senderAddress is not defined");return o[i].sendTokens(e,t,n,r,s)},re=async({senderAddress:e,recipientAddress:t,transferAmount:n,sourcePort:r,sourceChannel:s,timeoutHeight:o,timeoutTimestamp:i,fee:u,memo:p})=>{let{signingClients:m}=a.getState();if(!(m!=null&&m.stargate))throw new Error("Stargate signing client is not ready");if(!e)throw new Error("senderAddress is not defined");return m.stargate.sendIbcTokens(e,t,n,r,s,o,i,u,p)},oe=async({senderAddress:e,msg:t,fee:n,options:r,label:s,codeId:o})=>{let{signingClients:i}=a.getState();if(!(i!=null&&i.cosmWasm))throw new Error("CosmWasm signing client is not ready");return i.cosmWasm.instantiate(e,o,t,s,n,r)},ie=async({senderAddress:e,msg:t,fee:n,contractAddress:r})=>{let{signingClients:s}=a.getState();if(!(s!=null&&s.cosmWasm))throw new Error("CosmWasm signing client is not ready");return s.cosmWasm.execute(e,r,t,n)},ae=async(e,t)=>{let{signingClients:n}=a.getState();if(!(n!=null&&n.cosmWasm))throw new Error("CosmWasm signing client is not ready");return await n.cosmWasm.queryContractSmart(e,t)},ce=(e,t)=>{let{signingClients:n}=a.getState();if(!(n!=null&&n.cosmWasm))throw new Error("CosmWasm signing client is not ready");let r=new TextEncoder().encode(t);return n.cosmWasm.queryContractRaw(e,r)};import{Bech32Address as Le}from"@keplr-wallet/cosmos";var pe={coinDenom:"axl",coinMinimalDenom:"uaxl",coinDecimals:6,coinGeckoId:"axelar-network",coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/axelar/images/axl.png"},Ve={coinDenom:"usdc",coinMinimalDenom:"uusdc",coinDecimals:6,coinGeckoId:"usd-coin",coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/axelar/images/usdc.png"},Ye={coinDenom:"dai",coinMinimalDenom:"dai-wei",coinDecimals:18,coinGeckoId:"dai",coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/axelar/images/dai.png"},Je={coinDenom:"usdt",coinMinimalDenom:"uusdt",coinDecimals:6,coinGeckoId:"tether",coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/axelar/images/usdt.png"},$e={coinDenom:"weth-wei",coinMinimalDenom:"weth",coinDecimals:18,coinGeckoId:"weth",coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/axelar/images/weth.png"},Xe={coinDenom:"wbtc-satoshi",coinMinimalDenom:"wbtc",coinDecimals:8,coinGeckoId:"wrapped-bitcoin",coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/axelar/images/wbtc.png"},ue=[pe,Ve,Ye,Je,$e,Xe],T={rpc:"https://rpc.axelar.strange.love",rest:"https://api.axelar.strange.love",chainId:"axelar-dojo-1",chainName:"Axelar",stakeCurrency:pe,bip44:{coinType:118},bech32Config:Le.defaultBech32Config("axelar"),currencies:ue,feeCurrencies:ue};import{Bech32Address as Ze}from"@keplr-wallet/cosmos";var le={coinDenom:"atom",coinMinimalDenom:"uatom",coinDecimals:6,coinGeckoId:"cosmos",coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/cosmoshub/images/atom.png"},me=[le],A={rpc:"https://rpc.cosmoshub.strange.love",rest:"https://api.cosmoshub.strange.love",chainId:"cosmoshub-4",chainName:"Cosmos Hub",stakeCurrency:le,bip44:{coinType:118},bech32Config:Ze.defaultBech32Config("cosmos"),currencies:me,feeCurrencies:me};import{Bech32Address as et}from"@keplr-wallet/cosmos";var de={coinDenom:"juno",coinMinimalDenom:"ujuno",coinDecimals:6,coinGeckoId:"juno-network",coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/juno/images/juno.png"},tt={coinDenom:"neta",coinMinimalDenom:"cw20:juno168ctmpyppk90d34p3jjy658zf5a5l3w8wk35wht6ccqj4mr0yv8s4j5awr",coinDecimals:6,coinGeckoId:"neta",coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/juno/images/neta.png"},nt={coinDenom:"marble",coinMinimalDenom:"cw20:juno1g2g7ucurum66d42g8k5twk34yegdq8c82858gz0tq2fc75zy7khssgnhjl",coinDecimals:3,coinGeckoId:"marble",coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/juno/images/marble.png"},st={coinDenom:"hope",coinMinimalDenom:"cw20:juno1re3x67ppxap48ygndmrc7har2cnc7tcxtm9nplcas4v0gc3wnmvs3s807z",coinDecimals:6,coinGeckoId:"hope-galaxy",coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/juno/images/hope.png"},rt={coinDenom:"rac",coinMinimalDenom:"cw20:juno1r4pzw8f9z0sypct5l9j906d47z998ulwvhvqe5xdwgy8wf84583sxwh0pa",coinDecimals:6,coinGeckoId:"racoon",coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/juno/images/rac.png"},ot={coinDenom:"block",coinMinimalDenom:"cw20:juno1y9rf7ql6ffwkv02hsgd4yruz23pn4w97p75e2slsnkm0mnamhzysvqnxaq",coinDecimals:6,coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/juno/images/block.png"},it={coinDenom:"dhk",coinMinimalDenom:"cw20:juno1tdjwrqmnztn2j3sj2ln9xnyps5hs48q3ddwjrz7jpv6mskappjys5czd49",coinDecimals:0,coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/juno/images/dhk.png"},at={coinDenom:"raw",coinMinimalDenom:"cw20:juno15u3dt79t6sxxa3x3kpkhzsy56edaa5a66wvt3kxmukqjz2sx0hes5sn38g",coinDecimals:6,coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/juno/images/raw.png",coinGeckoId:"junoswap-raw-dao"},ct={coinDenom:"asvt",coinMinimalDenom:"cw20:juno17wzaxtfdw5em7lc94yed4ylgjme63eh73lm3lutp2rhcxttyvpwsypjm4w",coinDecimals:6,coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/juno/images/asvt.png"},ut={coinDenom:"hns",coinMinimalDenom:"cw20:juno1ur4jx0sxchdevahep7fwq28yk4tqsrhshdtylz46yka3uf6kky5qllqp4k",coinDecimals:6,coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/juno/images/hns.svg"},pt={coinDenom:"joe",coinMinimalDenom:"cw20:juno1n7n7d5088qlzlj37e9mgmkhx6dfgtvt02hqxq66lcap4dxnzdhwqfmgng3",coinDecimals:6,coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/juno/images/joe.png"},ge=[de,tt,nt,st,rt,ot,it,at,ct,ut,pt],k={rpc:"https://rpc.juno.strange.love",rest:"https://api.juno.strange.love",chainId:"juno-1",chainName:"Juno",stakeCurrency:de,bip44:{coinType:118},bech32Config:et.defaultBech32Config("juno"),currencies:ge,feeCurrencies:ge};import{Bech32Address as mt}from"@keplr-wallet/cosmos";var Ce={coinDenom:"osmo",coinMinimalDenom:"uosmo",coinDecimals:6,coinGeckoId:"osmosis",coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/cosmoshub/images/atom.png"},lt={coinDenom:"ion",coinMinimalDenom:"uion",coinDecimals:6,coinGeckoId:"ion",coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/osmosis/images/ion.png"},ye=[Ce,lt],v={rpc:"https://rpc.osmosis.strange.love",rest:"https://api.osmosis.strange.love",chainId:"osmosis-1",chainName:"Osmosis",stakeCurrency:Ce,bip44:{coinType:118},bech32Config:mt.defaultBech32Config("osmo"),currencies:ye,feeCurrencies:ye};import{Bech32Address as gt}from"@keplr-wallet/cosmos";var xe={coinDenom:"somm",coinMinimalDenom:"usomm",coinDecimals:6,coinGeckoId:"sommelier",coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/sommelier/images/somm.png"},fe=[xe],B={rpc:"https://rpc.sommelier.strange.love",rest:"https://api.sommelier.strange.love",chainId:"sommelier-3",chainName:"Sommelier",stakeCurrency:xe,bip44:{coinType:118},bech32Config:gt.defaultBech32Config("somm"),currencies:fe,feeCurrencies:fe};import{Bech32Address as dt}from"@keplr-wallet/cosmos";var Ae={coinDenom:"CRE",coinMinimalDenom:"ucre",coinDecimals:6,coinGeckoId:"crescent",coinImageUrl:"https://raw.githubusercontent.com/crescent-network/asset/main/images/coin/CRE.png"},he=[Ae],q={rpc:"https://testnet-endpoint.crescent.network/rpc/crescent",rest:"https://testnet-endpoint.crescent.network/api/crescent",chainId:"mooncat-1-1",chainName:"Crescent Testnet",bip44:{coinType:118},bech32Config:dt.defaultBech32Config("CRE"),currencies:he,feeCurrencies:he,stakeCurrency:Ae,coinType:118};import{Bech32Address as yt}from"@keplr-wallet/cosmos";var U={coinDenom:"junox",coinMinimalDenom:"ujunox",coinDecimals:6,coinGeckoId:"juno-network",coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/juno/images/juno.png"},Ct=[U],R={rpc:"https://rpc.uni.junonetwork.io",rest:"https://api.uni.junonetwork.io",chainId:"uni-5",chainName:"Juno Testnet",stakeCurrency:U,bip44:{coinType:118},bech32Config:yt.defaultBech32Config("juno"),currencies:Ct,feeCurrencies:[U],coinType:118};import{Bech32Address as ft}from"@keplr-wallet/cosmos";var G={coinDenom:"osmo",coinMinimalDenom:"uosmo",coinDecimals:6,coinGeckoId:"osmosis",coinImageUrl:"https://dhj8dql1kzq2v.cloudfront.net/white/osmo.png"},xt=[G],M={rpc:"https://testnet-rpc.osmosis.zone",rest:"https://testnet-rest.osmosis.zone",chainId:"osmo-test-4",chainName:"Osmosis Testnet",stakeCurrency:G,bip44:{coinType:118},bech32Config:ft.defaultBech32Config("osmo"),currencies:xt,feeCurrencies:[G],coinType:118};var Se=e=>e,On=e=>e,zn=e=>e,Wn=Se({axelar:T,cosmos:A,cosmoshub:A,juno:k,osmosis:v,sommelier:B}),_n=[T,A,k,v,B],Fn=Se({crescent:q,juno:R,osmosis:M}),Nn=[q,R,M];import{useMutation as Ee,useQuery as K}from"@tanstack/react-query";import{useEffect as At}from"react";import St from"zustand/shallow";import{useQuery as ht}from"@tanstack/react-query";var Jn=()=>f("keplr"),f=e=>{let t=a(s=>e||s.walletType);return ht(["USE_CHECK_WALLET",t],({queryKey:[,s]})=>D(s))};var g=({onConnect:e,onDisconnect:t}={})=>{let n=a(s=>s.account),r=a(s=>s.status);return At(()=>a.subscribe(s=>s.status,(s,o)=>{if(s==="connected"){let i=a.getState();e==null||e({account:i.account,isReconnect:o==="reconnecting"})}s==="disconnected"&&(t==null||t())}),[e,t]),{data:n,isConnected:Boolean(n),isConnecting:r==="connecting",isDisconnected:r==="disconnected",isReconnecting:r==="reconnecting",reconnect:d,status:r}},Et=e=>{let{data:t}=g(),n=e||(t==null?void 0:t.bech32Address);return K(["USE_BALANCES",n],({queryKey:[,o]})=>te(o),{enabled:Boolean(n)})},os=(e,t)=>{let{data:n}=Et(t);return K(["USE_BALANCE",n,e,t],({queryKey:[,o]})=>o==null?void 0:o.find(i=>i.denom===e),{enabled:Boolean(n)})},is=({onError:e,onLoading:t,onSuccess:n}={})=>{let s=Ee(["USE_CONNECT",e,t,n],C,{onError:(i,u)=>Promise.resolve(e==null?void 0:e(i,u)),onMutate:t,onSuccess:i=>Promise.resolve(n==null?void 0:n(i))}),{data:o}=f();return{connect:i=>s.mutate(i),connectAsync:i=>s.mutateAsync(i),error:s.error,isLoading:s.isLoading,isSuccess:s.isSuccess,isSupported:Boolean(o),status:s.status}},as=({onError:e,onLoading:t,onSuccess:n}={})=>{let s=Ee(["USE_DISCONNECT",e,t,n],H,{onError:o=>Promise.resolve(e==null?void 0:e(o,void 0)),onMutate:t,onSuccess:()=>Promise.resolve(n==null?void 0:n(void 0))});return{disconnect:o=>s.mutate(o),disconnectAsync:o=>s.mutateAsync(o),error:s.error,isLoading:s.isLoading,isSuccess:s.isSuccess,status:s.status}},bt=()=>a(e=>({signer:e.offlineSigner,signerAmino:e.offlineSignerAmino,signerAuto:e.offlineSignerAuto}),St),cs=()=>bt(),us=e=>{let{data:t}=g(),n=e||(t==null?void 0:t.bech32Address);return K(["USE_BALANCE_STAKED",n],({queryKey:[,o]})=>ne(n),{enabled:Boolean(n)})};import{useMutation as be,useQuery as we}from"@tanstack/react-query";var ys=()=>a(e=>e.activeChain),Cs=e=>we(["USE_ACTIVE_CHAIN_CURRENCY",e],({queryKey:[,r]})=>V(r)),fs=(e,t="BOND_STATUS_BONDED")=>we(["USE_ACTIVE_CHAIN_VALIDATORS",e,t],({queryKey:[,s,o]})=>s.staking.validators(o),{enabled:typeof e<"u"}),xs=()=>({data:a(t=>t.recentChain),clear:L}),hs=({onError:e,onLoading:t,onSuccess:n}={})=>{let s=be(["USE_SUGGEST_CHAIN",e,t,n],j,{onError:(o,i)=>Promise.resolve(e==null?void 0:e(o,i)),onMutate:t,onSuccess:o=>Promise.resolve(n==null?void 0:n(o))});return{error:s.error,isLoading:s.isLoading,isSuccess:s.isSuccess,suggest:s.mutate,suggestAsync:s.mutateAsync,status:s.status}},As=({onError:e,onLoading:t,onSuccess:n}={})=>{let s=be(["USE_SUGGEST_CHAIN_AND_CONNECT",e,t,n],Y,{onError:(i,u)=>Promise.resolve(e==null?void 0:e(i,u)),onMutate:i=>t==null?void 0:t(i),onSuccess:i=>Promise.resolve(n==null?void 0:n(i))}),{data:o}=f();return{error:s.error,isLoading:s.isLoading,isSuccess:s.isSuccess,isSupported:Boolean(o),status:s.status,suggestAndConnect:s.mutate,suggestAndConnectAsync:s.mutateAsync}};import{useQuery as De}from"@tanstack/react-query";import{useQuery as wt}from"@tanstack/react-query";var ws=(...e)=>{let t=["USE_QUERY_CLIENT",...e];return wt(t,({queryKey:[,...r]})=>_(...e),{refetchOnMount:!1,refetchOnWindowFocus:!1})};var ks=e=>{let t=a(s=>s.clients);return De(["USE_CLIENTS",e,t],({queryKey:[,s,o]})=>s!=null&&s.rpc?x(s):o,{refetchOnMount:!1,refetchOnWindowFocus:!1})},vs=e=>{let t=a(s=>s.signingClients);return De(["USE_SIGNING_CLIENTS",e,t],({queryKey:[,s,o]})=>s!=null&&s.rpc?h(s):o,{refetchOnMount:!1,refetchOnWindowFocus:!1})};import{useMutation as Dt,useQuery as S}from"@tanstack/react-query";var Gs=({address:e,isTestnet:t})=>S(["USE_ADRESS_TO_IBC_DOMAIN",e,t],()=>$(e,t),{enabled:Boolean(e)}),Ms=({ibcDomain:e,isTestnet:t})=>S(["USE_IBC_DOMAIN_TO_ADDRESSES",e,t],()=>X(e,t),{enabled:Boolean(e)}),Ks=({ibcDomain:e,prefix:t,isTestnet:n})=>S(["USE_IBC_DOMAIN_TO_CHAIN_ADDRESS",t,e,n],()=>I(e,t,n),{enabled:Boolean(e&&t)}),Qs=({ibcDomain:e,isTestnet:t})=>S(["USE_IBC_DOMAIN_DETAILS",e,t],()=>Z(e,t),{enabled:Boolean(e)}),Ps=({onError:e,onLoading:t,onSuccess:n}={})=>{let s=Dt(["USE_RESOLVE_TO_CHAIN_ADDRESS",e,t,n],ee,{onError:(o,i)=>Promise.resolve(e==null?void 0:e(o,i)),onMutate:t,onSuccess:o=>Promise.resolve(n==null?void 0:n(o))});return{error:s.error,isLoading:s.isLoading,isSuccess:s.isSuccess,resolveToChainAddress:s.mutate,resolveToChainAddressAsync:s.mutateAsync,status:s.status}};import{useMutation as E,useQuery as je}from"@tanstack/react-query";var Fs=({onError:e,onLoading:t,onSuccess:n}={})=>{let{data:r}=g(),s=r==null?void 0:r.bech32Address,i=E(["USE_SEND_TOKENS",e,t,n,s],u=>se({senderAddress:s,...u}),{onError:(u,p)=>Promise.resolve(e==null?void 0:e(u,p)),onMutate:t,onSuccess:u=>Promise.resolve(n==null?void 0:n(u))});return{error:i.error,isLoading:i.isLoading,isSuccess:i.isSuccess,sendTokens:i.mutate,sendTokensAsync:i.mutateAsync,status:i.status}},Ns=({onError:e,onLoading:t,onSuccess:n}={})=>{let{data:r}=g(),s=r==null?void 0:r.bech32Address,i=E(["USE_SEND_IBC_TOKENS",e,t,n,s],u=>re({senderAddress:s,...u}),{onError:(u,p)=>Promise.resolve(e==null?void 0:e(u,p)),onMutate:t,onSuccess:u=>Promise.resolve(n==null?void 0:n(u))});return{error:i.error,isLoading:i.isLoading,isSuccess:i.isSuccess,sendIbcTokens:i.mutate,sendIbcTokensAsync:i.mutateAsync,status:i.status}},Hs=({codeId:e,onError:t,onLoading:n,onSuccess:r})=>{let{data:s}=g(),o=s==null?void 0:s.bech32Address,p=E(["USE_INSTANTIATE_CONTRACT",t,n,r,e,o],m=>{if(!o)throw new Error("senderAddress is undefined");let l={...m,fee:m.fee??"auto",senderAddress:o,codeId:e};return oe(l)},{onError:(m,l)=>Promise.resolve(t==null?void 0:t(m,l)),onMutate:n,onSuccess:m=>Promise.resolve(r==null?void 0:r(m))});return{error:p.error,isLoading:p.isLoading,isSuccess:p.isSuccess,instantiateContract:p.mutate,instantiateContractAsync:p.mutateAsync,status:p.status}},Ls=({contractAddress:e,onError:t,onLoading:n,onSuccess:r})=>{let{data:s}=g(),o=s==null?void 0:s.bech32Address,p=E(["USE_EXECUTE_CONTRACT",t,n,r,e,o],m=>{if(!o)throw new Error("senderAddress is undefined");let l={...m,fee:m.fee??"auto",senderAddress:o,contractAddress:e};return ie(l)},{onError:(m,l)=>Promise.resolve(t==null?void 0:t(m,l)),onMutate:n,onSuccess:m=>Promise.resolve(r==null?void 0:r(m))});return{error:p.error,isLoading:p.isLoading,isSuccess:p.isSuccess,executeContract:p.mutate,executeContractAsync:p.mutateAsync,status:p.status}},Vs=(e,t)=>je(["USE_QUERY_SMART",e,t],({queryKey:[,s]})=>{if(!e||!t)throw new Error("address or queryMsg undefined");return ae(e,t)},{enabled:Boolean(e)&&Boolean(t)}),Ys=(e,t)=>je(["USE_QUERY_RAW",t,e],({queryKey:[,s]})=>{if(!e||!t)throw new Error("address or key undefined");return ce(e,t)},{enabled:Boolean(e)&&Boolean(t)});import{QueryClient as Tt,QueryClientProvider as kt}from"@tanstack/react-query";import{useEffect as jt}from"react";var It=()=>(jt(()=>{let{_reconnect:e}=a.getState();return e&&d(),window.addEventListener("keplr_keystorechange",d),()=>{window.removeEventListener("keplr_keystorechange",d)}},[]),null),Ie=()=>(It(),null);import{jsx as Bt,jsxs as qt}from"react/jsx-runtime";var vt=new Tt({}),rr=({children:e,grazOptions:t,...n})=>(t&&J(t),qt(kt,{client:vt,...n,children:[Bt(Ie,{}),e]}));export{Ie as GrazEvents,rr as GrazProvider,O as WALLET_TYPES,P as WalletType,D as checkWallet,L as clearRecentChain,J as configureGraz,C as connect,x as createClients,_ as createQueryClient,h as createSigningClients,On as defineChain,zn as defineChainInfo,Se as defineChains,H as disconnect,ie as executeContract,V as getActiveChainCurrency,X as getAddressesByIbcDomain,Yt as getAvailableWallets,ne as getBalanceStaked,te as getBalances,I as getChainAddressByIbcDomain,$ as getIbcDomainByAdress,Z as getIbcDomainDetails,Ke as getKeplr,Qe as getLeap,ce as getQueryRaw,ae as getQuerySmart,on as getRecentChain,y as getWallet,oe as instantiateContract,Ne as isIbcDomainPostfix,Wn as mainnetChains,_n as mainnetChainsArray,d as reconnect,ee as resolveToChainAddress,re as sendIbcTokens,se as sendTokens,j as suggestChain,Y as suggestChainAndConnect,Fn as testnetChains,Nn as testnetChainsArray,g as useAccount,ys as useActiveChain,Cs as useActiveChainCurrency,fs as useActiveChainValidators,Gs as useAddressToIbcDomain,os as useBalance,us as useBalanceStaked,Et as useBalances,Jn as useCheckKeplr,f as useCheckWallet,ks as useClients,is as useConnect,as as useDisconnect,Ls as useExecuteContract,It as useGrazEvents,Qs as useIbcDomainDetails,Ms as useIbcDomainToAddresses,Ks as useIbcDomainToChainAddress,Hs as useInstantiateContract,bt as useOfflineSigners,ws as useQueryClient,Ys as useQueryRaw,Vs as useQuerySmart,xs as useRecentChain,Ps as useResolveToChainAddress,Ns as useSendIbcTokens,Fs as useSendTokens,cs as useSigners,vs as useSigningClients,hs as useSuggestChain,As as useSuggestChainAndConnect,He as validateAddress};
