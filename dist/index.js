"use strict";var ot=Object.create;var j=Object.defineProperty;var it=Object.getOwnPropertyDescriptor;var at=Object.getOwnPropertyNames;var ct=Object.getPrototypeOf,ut=Object.prototype.hasOwnProperty;var pt=(e,t)=>{for(var n in t)j(e,n,{get:t[n],enumerable:!0})},fe=(e,t,n,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let s of at(t))!ut.call(e,s)&&s!==n&&j(e,s,{get:()=>t[s],enumerable:!(r=it(t,s))||r.enumerable});return e};var xe=(e,t,n)=>(n=e!=null?ot(ct(e)):{},fe(t||!e||!e.__esModule?j(n,"default",{value:e,enumerable:!0}):n,e)),mt=e=>fe(j({},"__esModule",{value:!0}),e);var dn={};pt(dn,{GrazEvents:()=>de,GrazProvider:()=>gn,WALLET_TYPES:()=>G,WalletType:()=>R,checkWallet:()=>T,clearRecentChain:()=>z,configureGraz:()=>F,connect:()=>S,createClients:()=>w,createQueryClient:()=>K,createSigningClients:()=>D,defineChain:()=>Ut,defineChainInfo:()=>Rt,defineChains:()=>le,disconnect:()=>O,executeContract:()=>ee,getActiveChainCurrency:()=>W,getAddressesByIbcDomain:()=>H,getAvailableWallets:()=>gt,getBalanceStaked:()=>J,getBalances:()=>Y,getChainAddressByIbcDomain:()=>v,getIbcDomainByAdress:()=>N,getIbcDomainDetails:()=>L,getKeplr:()=>Ee,getLeap:()=>be,getQueryRaw:()=>ne,getQuerySmart:()=>te,getRecentChain:()=>dt,getWallet:()=>A,instantiateContract:()=>Z,isIbcDomainPostfix:()=>je,mainnetChains:()=>Gt,mainnetChainsArray:()=>Mt,reconnect:()=>C,resolveToChainAddress:()=>V,sendIbcTokens:()=>X,sendTokens:()=>$,suggestChain:()=>k,suggestChainAndConnect:()=>_,testnetChains:()=>Kt,testnetChainsArray:()=>Qt,useAccount:()=>d,useActiveChain:()=>Nt,useActiveChainCurrency:()=>Ht,useActiveChainValidators:()=>Lt,useAddressToIbcDomain:()=>en,useBalance:()=>Ot,useBalanceStaked:()=>Ft,useBalances:()=>$e,useCheckKeplr:()=>Pt,useCheckWallet:()=>E,useClients:()=>Xt,useConnect:()=>zt,useDisconnect:()=>Wt,useExecuteContract:()=>un,useGrazEvents:()=>tt,useIbcDomainDetails:()=>sn,useIbcDomainToAddresses:()=>tn,useIbcDomainToChainAddress:()=>nn,useInstantiateContract:()=>cn,useOfflineSigners:()=>Xe,useQueryClient:()=>$t,useQueryRaw:()=>mn,useQuerySmart:()=>pn,useRecentChain:()=>Vt,useResolveToChainAddress:()=>rn,useSendIbcTokens:()=>an,useSendTokens:()=>on,useSigners:()=>_t,useSigningClients:()=>Zt,useSuggestChain:()=>Yt,useSuggestChainAndConnect:()=>Jt,validateAddress:()=>Ie});module.exports=mt(dn);var we=require("@cosmjs/stargate");var he=xe(require("zustand")),I=require("zustand/middleware");var R=(n=>(n.KEPLR="keplr",n.LEAP="leap",n))(R||{}),G=["keplr","leap"];var M={account:null,activeChain:null,balances:null,clients:null,defaultChain:null,defaultSigningClient:"stargate",offlineSigner:null,offlineSignerAmino:null,offlineSignerAuto:null,recentChain:null,signingClients:null,status:"disconnected",walletType:"keplr",_notFoundFn:()=>null,_reconnect:!1},lt={name:"graz",partialize:e=>({activeChain:e.activeChain,recentChain:e.recentChain,_reconnect:e._reconnect}),version:1},a=(0,he.default)((0,I.subscribeWithSelector)((0,I.persist)(()=>M,lt)));var Q=require("@cosmjs/cosmwasm-stargate"),P=require("@cosmjs/stargate"),Se=require("@cosmjs/tendermint-rpc");var Ae=require("@cosmjs/stargate"),h=require("@cosmjs/utils");var K=(...e)=>{let{tendermint:t}=a.getState().clients,n=new Ae.QueryClient(t),r=e.map(s=>s(n));for(let s of r){(0,h.assert)((0,h.isNonNullObject)(s),"Extension must be a non-null object");for(let[o,i]of Object.entries(s)){(0,h.assert)((0,h.isNonNullObject)(i),`Module must be a non-null object. Found type ${typeof i} for module "${o}".`);let u=n[o]||{};n[o]={...u,...i}}}return n};var w=async({rpc:e,rpcHeaders:t})=>{let n={url:e,headers:{...t||{}}},[r,s,o]=await Promise.all([Q.SigningCosmWasmClient.connect(n),P.SigningStargateClient.connect(n),Se.Tendermint34Client.connect(n)]);return{cosmWasm:r,stargate:s,tendermint:o}},D=async e=>{let{rpc:t,rpcHeaders:n,offlineSignerAuto:r,cosmWasmSignerOptions:s={},stargateSignerOptions:o={}}=e,i={url:t,headers:{...n||{}}},[u,p]=await Promise.all([Q.SigningCosmWasmClient.connectWithSigner(i,r,s),P.SigningStargateClient.connectWithSigner(i,r,o)]);return{cosmWasm:u,stargate:p}};var T=(e=a.getState().walletType)=>{try{return A(e),!0}catch(t){return console.error(t),!1}},Ee=()=>{if(typeof window.keplr<"u")return window.keplr;throw a.getState()._notFoundFn(),new Error("window.keplr is not defined")},be=()=>{if(typeof window.leap<"u")return window.leap;throw a.getState()._notFoundFn(),new Error("window.leap is not defined")},A=(e=a.getState().walletType)=>{switch(e){case"keplr":return Ee();case"leap":return be();default:throw new Error("Unknown wallet type")}},gt=()=>Object.fromEntries(G.map(e=>[e,T(e)]));var S=async e=>{try{let{defaultChain:t,recentChain:n,walletType:r}=a.getState(),s=(e==null?void 0:e.walletType)||r,o=A(s),i=e||n||t;if(!i)throw new Error("No last known connected chain, connect action requires chain info");a.setState(U=>{let rt=U._reconnect;return U.activeChain&&U.activeChain.chainId!==i.chainId?{status:"connecting"}:rt?{status:"reconnecting"}:{status:"connecting"}}),await o.enable(i.chainId);let u=o.getOfflineSigner(i.chainId),p=o.getOfflineSignerOnlyAmino(i.chainId),m=await o.getOfflineSignerAuto(i.chainId),l=i.gas?we.GasPrice.fromString(`${i.gas.price}${i.gas.denom}`):void 0,[Ce,nt,st]=await Promise.all([o.getKey(i.chainId),w(i),D({...i,offlineSignerAuto:m,cosmWasmSignerOptions:{gasPrice:l,...(e==null?void 0:e.signerOpts)||{}}})]);return a.setState({account:Ce,activeChain:i,clients:nt,offlineSigner:u,offlineSignerAmino:p,offlineSignerAuto:m,recentChain:i,signingClients:st,status:"connected",walletType:s,_reconnect:!0}),Ce}catch(t){throw a.getState().account===null&&a.setState({status:"disconnected"}),t}},O=async(e=!1)=>(a.setState(t=>({...M,recentChain:e?null:t.recentChain})),Promise.resolve()),C=()=>{let{activeChain:e}=a.getState();e&&S(e)};var z=()=>{a.setState({recentChain:null})},W=e=>{let{activeChain:t}=a.getState();return t==null?void 0:t.currencies.find(n=>n.coinMinimalDenom===e)},dt=()=>a.getState().recentChain,k=async e=>(await A().experimentalSuggestChain(e),e),_=async({chainInfo:e,...t})=>{let n=await k(e);return{account:await S({chainId:e.chainId,currencies:e.currencies,rest:e.rest,rpc:e.rpc,...t}),chain:n}};var F=(e={})=>(a.setState(t=>({defaultChain:e.defaultChain||t.defaultChain,defaultSigningClient:e.defaultSigningClient||t.defaultSigningClient,walletType:e.defaultWallet||t.walletType,_notFoundFn:e.onNotFound||t._notFoundFn})),e);var De=require("bech32"),g=require("ibc-domains-sdk"),je=e=>e.endsWith(".cosmos"),Ie=(e,t)=>{if(!e)return!1;try{return De.bech32.decode(e).prefix===t}catch{return!1}},N=async(e,t)=>{let n=await(0,g.resolvePrimaryDomainByAddress)(e,t);if(n.error)throw new Error(n.error);if(n.value===null)return null;let r=n.value;return{domain:r.domain,domainFull:r.domain_full}},H=async(e,t)=>{let n=await(0,g.resolveDomainIntoAddresses)(e,t);if(n.error)throw new Error(n.error);return n.value===null?null:n.value},v=async(e,t,n)=>{let r=await(0,g.resolveDomainIntoChainAddress)(e,t,n);if(r.error)throw new Error(r.error);return r.value===null?null:r.value},L=async(e,t)=>{let n=await(0,g.resolveDomainDetails)(e,t);if(n.error)throw new Error(n.error);return n.value===null?null:n.value},V=async({value:e,prefix:t,isTestnet:n})=>{if(e.trim()==="")throw new Error("value can't be an empty string");if(je(e)){let o=await v(e,t,n);if(!o)throw new Error("ibc domain not found");return o}if(!Ie(e,t))throw new Error("Address is not valid");return e};var Y=async e=>{let{activeChain:t,signingClients:n}=a.getState();if(!t||!n)throw new Error("No connected account detected");let{defaultSigningClient:r}=a.getState();return await Promise.all(t.currencies.map(async o=>n[r].getBalance(e,o.coinMinimalDenom)))},J=async e=>{let{clients:t}=a.getState();if(!(t!=null&&t.stargate))throw new Error("Stargate client is not ready");return t.stargate.getBalanceStaked(e)},$=async({senderAddress:e,recipientAddress:t,amount:n,fee:r,memo:s})=>{let{signingClients:o,defaultSigningClient:i}=a.getState();if(!o)throw new Error("No connected account detected");if(!e)throw new Error("senderAddress is not defined");return o[i].sendTokens(e,t,n,r,s)},X=async({senderAddress:e,recipientAddress:t,transferAmount:n,sourcePort:r,sourceChannel:s,timeoutHeight:o,timeoutTimestamp:i,fee:u,memo:p})=>{let{signingClients:m}=a.getState();if(!(m!=null&&m.stargate))throw new Error("Stargate signing client is not ready");if(!e)throw new Error("senderAddress is not defined");return m.stargate.sendIbcTokens(e,t,n,r,s,o,i,u,p)},Z=async({senderAddress:e,msg:t,fee:n,options:r,label:s,codeId:o})=>{let{signingClients:i}=a.getState();if(!(i!=null&&i.cosmWasm))throw new Error("CosmWasm signing client is not ready");return i.cosmWasm.instantiate(e,o,t,s,n,r)},ee=async({senderAddress:e,msg:t,fee:n,contractAddress:r})=>{let{signingClients:s}=a.getState();if(!(s!=null&&s.cosmWasm))throw new Error("CosmWasm signing client is not ready");return s.cosmWasm.execute(e,r,t,n)},te=async(e,t)=>{let{signingClients:n}=a.getState();if(!(n!=null&&n.cosmWasm))throw new Error("CosmWasm signing client is not ready");return await n.cosmWasm.queryContractSmart(e,t)},ne=(e,t)=>{let{signingClients:n}=a.getState();if(!(n!=null&&n.cosmWasm))throw new Error("CosmWasm signing client is not ready");let r=new TextEncoder().encode(t);return n.cosmWasm.queryContractRaw(e,r)};var ke=require("@keplr-wallet/cosmos"),ve={coinDenom:"axl",coinMinimalDenom:"uaxl",coinDecimals:6,coinGeckoId:"axelar-network",coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/axelar/images/axl.png"},yt={coinDenom:"usdc",coinMinimalDenom:"uusdc",coinDecimals:6,coinGeckoId:"usd-coin",coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/axelar/images/usdc.png"},Ct={coinDenom:"dai",coinMinimalDenom:"dai-wei",coinDecimals:18,coinGeckoId:"dai",coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/axelar/images/dai.png"},ft={coinDenom:"usdt",coinMinimalDenom:"uusdt",coinDecimals:6,coinGeckoId:"tether",coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/axelar/images/usdt.png"},xt={coinDenom:"weth-wei",coinMinimalDenom:"weth",coinDecimals:18,coinGeckoId:"weth",coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/axelar/images/weth.png"},ht={coinDenom:"wbtc-satoshi",coinMinimalDenom:"wbtc",coinDecimals:8,coinGeckoId:"wrapped-bitcoin",coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/axelar/images/wbtc.png"},Te=[ve,yt,Ct,ft,xt,ht],se={rpc:"https://rpc.axelar.strange.love",rest:"https://api.axelar.strange.love",chainId:"axelar-dojo-1",chainName:"Axelar",stakeCurrency:ve,bip44:{coinType:118},bech32Config:ke.Bech32Address.defaultBech32Config("axelar"),currencies:Te,feeCurrencies:Te};var qe=require("@keplr-wallet/cosmos"),Ue={coinDenom:"atom",coinMinimalDenom:"uatom",coinDecimals:6,coinGeckoId:"cosmos",coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/cosmoshub/images/atom.png"},Be=[Ue],B={rpc:"https://rpc.cosmoshub.strange.love",rest:"https://api.cosmoshub.strange.love",chainId:"cosmoshub-4",chainName:"Cosmos Hub",stakeCurrency:Ue,bip44:{coinType:118},bech32Config:qe.Bech32Address.defaultBech32Config("cosmos"),currencies:Be,feeCurrencies:Be};var Ge=require("@keplr-wallet/cosmos"),Me={coinDenom:"juno",coinMinimalDenom:"ujuno",coinDecimals:6,coinGeckoId:"juno-network",coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/juno/images/juno.png"},At={coinDenom:"neta",coinMinimalDenom:"cw20:juno168ctmpyppk90d34p3jjy658zf5a5l3w8wk35wht6ccqj4mr0yv8s4j5awr",coinDecimals:6,coinGeckoId:"neta",coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/juno/images/neta.png"},St={coinDenom:"marble",coinMinimalDenom:"cw20:juno1g2g7ucurum66d42g8k5twk34yegdq8c82858gz0tq2fc75zy7khssgnhjl",coinDecimals:3,coinGeckoId:"marble",coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/juno/images/marble.png"},Et={coinDenom:"hope",coinMinimalDenom:"cw20:juno1re3x67ppxap48ygndmrc7har2cnc7tcxtm9nplcas4v0gc3wnmvs3s807z",coinDecimals:6,coinGeckoId:"hope-galaxy",coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/juno/images/hope.png"},bt={coinDenom:"rac",coinMinimalDenom:"cw20:juno1r4pzw8f9z0sypct5l9j906d47z998ulwvhvqe5xdwgy8wf84583sxwh0pa",coinDecimals:6,coinGeckoId:"racoon",coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/juno/images/rac.png"},wt={coinDenom:"block",coinMinimalDenom:"cw20:juno1y9rf7ql6ffwkv02hsgd4yruz23pn4w97p75e2slsnkm0mnamhzysvqnxaq",coinDecimals:6,coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/juno/images/block.png"},Dt={coinDenom:"dhk",coinMinimalDenom:"cw20:juno1tdjwrqmnztn2j3sj2ln9xnyps5hs48q3ddwjrz7jpv6mskappjys5czd49",coinDecimals:0,coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/juno/images/dhk.png"},jt={coinDenom:"raw",coinMinimalDenom:"cw20:juno15u3dt79t6sxxa3x3kpkhzsy56edaa5a66wvt3kxmukqjz2sx0hes5sn38g",coinDecimals:6,coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/juno/images/raw.png",coinGeckoId:"junoswap-raw-dao"},It={coinDenom:"asvt",coinMinimalDenom:"cw20:juno17wzaxtfdw5em7lc94yed4ylgjme63eh73lm3lutp2rhcxttyvpwsypjm4w",coinDecimals:6,coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/juno/images/asvt.png"},Tt={coinDenom:"hns",coinMinimalDenom:"cw20:juno1ur4jx0sxchdevahep7fwq28yk4tqsrhshdtylz46yka3uf6kky5qllqp4k",coinDecimals:6,coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/juno/images/hns.svg"},kt={coinDenom:"joe",coinMinimalDenom:"cw20:juno1n7n7d5088qlzlj37e9mgmkhx6dfgtvt02hqxq66lcap4dxnzdhwqfmgng3",coinDecimals:6,coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/juno/images/joe.png"},Re=[Me,At,St,Et,bt,wt,Dt,jt,It,Tt,kt],re={rpc:"https://rpc.juno.strange.love",rest:"https://api.juno.strange.love",chainId:"juno-1",chainName:"Juno",stakeCurrency:Me,bip44:{coinType:118},bech32Config:Ge.Bech32Address.defaultBech32Config("juno"),currencies:Re,feeCurrencies:Re};var Qe=require("@keplr-wallet/cosmos"),Pe={coinDenom:"osmo",coinMinimalDenom:"uosmo",coinDecimals:6,coinGeckoId:"osmosis",coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/cosmoshub/images/atom.png"},vt={coinDenom:"ion",coinMinimalDenom:"uion",coinDecimals:6,coinGeckoId:"ion",coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/osmosis/images/ion.png"},Ke=[Pe,vt],oe={rpc:"https://rpc.osmosis.strange.love",rest:"https://api.osmosis.strange.love",chainId:"osmosis-1",chainName:"Osmosis",stakeCurrency:Pe,bip44:{coinType:118},bech32Config:Qe.Bech32Address.defaultBech32Config("osmo"),currencies:Ke,feeCurrencies:Ke};var ze=require("@keplr-wallet/cosmos"),We={coinDenom:"somm",coinMinimalDenom:"usomm",coinDecimals:6,coinGeckoId:"sommelier",coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/sommelier/images/somm.png"},Oe=[We],ie={rpc:"https://rpc.sommelier.strange.love",rest:"https://api.sommelier.strange.love",chainId:"sommelier-3",chainName:"Sommelier",stakeCurrency:We,bip44:{coinType:118},bech32Config:ze.Bech32Address.defaultBech32Config("somm"),currencies:Oe,feeCurrencies:Oe};var Fe=require("@keplr-wallet/cosmos"),Ne={coinDenom:"CRE",coinMinimalDenom:"ucre",coinDecimals:6,coinGeckoId:"crescent",coinImageUrl:"https://raw.githubusercontent.com/crescent-network/asset/main/images/coin/CRE.png"},_e=[Ne],ae={rpc:"https://testnet-endpoint.crescent.network/rpc/crescent",rest:"https://testnet-endpoint.crescent.network/api/crescent",chainId:"mooncat-1-1",chainName:"Crescent Testnet",bip44:{coinType:118},bech32Config:Fe.Bech32Address.defaultBech32Config("CRE"),currencies:_e,feeCurrencies:_e,stakeCurrency:Ne,coinType:118};var He=require("@keplr-wallet/cosmos"),ce={coinDenom:"junox",coinMinimalDenom:"ujunox",coinDecimals:6,coinGeckoId:"juno-network",coinImageUrl:"https://raw.githubusercontent.com/cosmos/chain-registry/master/juno/images/juno.png"},Bt=[ce],ue={rpc:"https://rpc.uni.junonetwork.io",rest:"https://api.uni.junonetwork.io",chainId:"uni-5",chainName:"Juno Testnet",stakeCurrency:ce,bip44:{coinType:118},bech32Config:He.Bech32Address.defaultBech32Config("juno"),currencies:Bt,feeCurrencies:[ce],coinType:118};var Le=require("@keplr-wallet/cosmos"),pe={coinDenom:"osmo",coinMinimalDenom:"uosmo",coinDecimals:6,coinGeckoId:"osmosis",coinImageUrl:"https://dhj8dql1kzq2v.cloudfront.net/white/osmo.png"},qt=[pe],me={rpc:"https://testnet-rpc.osmosis.zone",rest:"https://testnet-rest.osmosis.zone",chainId:"osmo-test-4",chainName:"Osmosis Testnet",stakeCurrency:pe,bip44:{coinType:118},bech32Config:Le.Bech32Address.defaultBech32Config("osmo"),currencies:qt,feeCurrencies:[pe],coinType:118};var le=e=>e,Ut=e=>e,Rt=e=>e,Gt=le({axelar:se,cosmos:B,cosmoshub:B,juno:re,osmosis:oe,sommelier:ie}),Mt=[se,B,re,oe,ie],Kt=le({crescent:ae,juno:ue,osmosis:me}),Qt=[ae,ue,me];var f=require("@tanstack/react-query"),Ye=require("react"),Je=xe(require("zustand/shallow"));var Ve=require("@tanstack/react-query");var Pt=()=>E("keplr"),E=e=>{let t=a(s=>e||s.walletType);return(0,Ve.useQuery)(["USE_CHECK_WALLET",t],({queryKey:[,s]})=>T(s))};var d=({onConnect:e,onDisconnect:t}={})=>{let n=a(s=>s.account),r=a(s=>s.status);return(0,Ye.useEffect)(()=>a.subscribe(s=>s.status,(s,o)=>{if(s==="connected"){let i=a.getState();e==null||e({account:i.account,isReconnect:o==="reconnecting"})}s==="disconnected"&&(t==null||t())}),[e,t]),{data:n,isConnected:Boolean(n),isConnecting:r==="connecting",isDisconnected:r==="disconnected",isReconnecting:r==="reconnecting",reconnect:C,status:r}},$e=e=>{let{data:t}=d(),n=e||(t==null?void 0:t.bech32Address);return(0,f.useQuery)(["USE_BALANCES",n],({queryKey:[,o]})=>Y(o),{enabled:Boolean(n)})},Ot=(e,t)=>{let{data:n}=$e(t);return(0,f.useQuery)(["USE_BALANCE",n,e,t],({queryKey:[,o]})=>o==null?void 0:o.find(i=>i.denom===e),{enabled:Boolean(n)})},zt=({onError:e,onLoading:t,onSuccess:n}={})=>{let s=(0,f.useMutation)(["USE_CONNECT",e,t,n],S,{onError:(i,u)=>Promise.resolve(e==null?void 0:e(i,u)),onMutate:t,onSuccess:i=>Promise.resolve(n==null?void 0:n(i))}),{data:o}=E();return{connect:i=>s.mutate(i),connectAsync:i=>s.mutateAsync(i),error:s.error,isLoading:s.isLoading,isSuccess:s.isSuccess,isSupported:Boolean(o),status:s.status}},Wt=({onError:e,onLoading:t,onSuccess:n}={})=>{let s=(0,f.useMutation)(["USE_DISCONNECT",e,t,n],O,{onError:o=>Promise.resolve(e==null?void 0:e(o,void 0)),onMutate:t,onSuccess:()=>Promise.resolve(n==null?void 0:n(void 0))});return{disconnect:o=>s.mutate(o),disconnectAsync:o=>s.mutateAsync(o),error:s.error,isLoading:s.isLoading,isSuccess:s.isSuccess,status:s.status}},Xe=()=>a(e=>({signer:e.offlineSigner,signerAmino:e.offlineSignerAmino,signerAuto:e.offlineSignerAuto}),Je.default),_t=()=>Xe(),Ft=e=>{let{data:t}=d(),n=e||(t==null?void 0:t.bech32Address);return(0,f.useQuery)(["USE_BALANCE_STAKED",n],({queryKey:[,o]})=>J(n),{enabled:Boolean(n)})};var b=require("@tanstack/react-query");var Nt=()=>a(e=>e.activeChain),Ht=e=>(0,b.useQuery)(["USE_ACTIVE_CHAIN_CURRENCY",e],({queryKey:[,r]})=>W(r)),Lt=(e,t="BOND_STATUS_BONDED")=>(0,b.useQuery)(["USE_ACTIVE_CHAIN_VALIDATORS",e,t],({queryKey:[,s,o]})=>s.staking.validators(o),{enabled:typeof e<"u"}),Vt=()=>({data:a(t=>t.recentChain),clear:z}),Yt=({onError:e,onLoading:t,onSuccess:n}={})=>{let s=(0,b.useMutation)(["USE_SUGGEST_CHAIN",e,t,n],k,{onError:(o,i)=>Promise.resolve(e==null?void 0:e(o,i)),onMutate:t,onSuccess:o=>Promise.resolve(n==null?void 0:n(o))});return{error:s.error,isLoading:s.isLoading,isSuccess:s.isSuccess,suggest:s.mutate,suggestAsync:s.mutateAsync,status:s.status}},Jt=({onError:e,onLoading:t,onSuccess:n}={})=>{let s=(0,b.useMutation)(["USE_SUGGEST_CHAIN_AND_CONNECT",e,t,n],_,{onError:(i,u)=>Promise.resolve(e==null?void 0:e(i,u)),onMutate:i=>t==null?void 0:t(i),onSuccess:i=>Promise.resolve(n==null?void 0:n(i))}),{data:o}=E();return{error:s.error,isLoading:s.isLoading,isSuccess:s.isSuccess,isSupported:Boolean(o),status:s.status,suggestAndConnect:s.mutate,suggestAndConnectAsync:s.mutateAsync}};var ge=require("@tanstack/react-query");var Ze=require("@tanstack/react-query");var $t=(...e)=>{let t=["USE_QUERY_CLIENT",...e];return(0,Ze.useQuery)(t,({queryKey:[,...r]})=>K(...e),{refetchOnMount:!1,refetchOnWindowFocus:!1})};var Xt=e=>{let t=a(s=>s.clients);return(0,ge.useQuery)(["USE_CLIENTS",e,t],({queryKey:[,s,o]})=>s!=null&&s.rpc?w(s):o,{refetchOnMount:!1,refetchOnWindowFocus:!1})},Zt=e=>{let t=a(s=>s.signingClients);return(0,ge.useQuery)(["USE_SIGNING_CLIENTS",e,t],({queryKey:[,s,o]})=>s!=null&&s.rpc?D(s):o,{refetchOnMount:!1,refetchOnWindowFocus:!1})};var x=require("@tanstack/react-query");var en=({address:e,isTestnet:t})=>(0,x.useQuery)(["USE_ADRESS_TO_IBC_DOMAIN",e,t],()=>N(e,t),{enabled:Boolean(e)}),tn=({ibcDomain:e,isTestnet:t})=>(0,x.useQuery)(["USE_IBC_DOMAIN_TO_ADDRESSES",e,t],()=>H(e,t),{enabled:Boolean(e)}),nn=({ibcDomain:e,prefix:t,isTestnet:n})=>(0,x.useQuery)(["USE_IBC_DOMAIN_TO_CHAIN_ADDRESS",t,e,n],()=>v(e,t,n),{enabled:Boolean(e&&t)}),sn=({ibcDomain:e,isTestnet:t})=>(0,x.useQuery)(["USE_IBC_DOMAIN_DETAILS",e,t],()=>L(e,t),{enabled:Boolean(e)}),rn=({onError:e,onLoading:t,onSuccess:n}={})=>{let s=(0,x.useMutation)(["USE_RESOLVE_TO_CHAIN_ADDRESS",e,t,n],V,{onError:(o,i)=>Promise.resolve(e==null?void 0:e(o,i)),onMutate:t,onSuccess:o=>Promise.resolve(n==null?void 0:n(o))});return{error:s.error,isLoading:s.isLoading,isSuccess:s.isSuccess,resolveToChainAddress:s.mutate,resolveToChainAddressAsync:s.mutateAsync,status:s.status}};var y=require("@tanstack/react-query");var on=({onError:e,onLoading:t,onSuccess:n}={})=>{let{data:r}=d(),s=r==null?void 0:r.bech32Address,i=(0,y.useMutation)(["USE_SEND_TOKENS",e,t,n,s],u=>$({senderAddress:s,...u}),{onError:(u,p)=>Promise.resolve(e==null?void 0:e(u,p)),onMutate:t,onSuccess:u=>Promise.resolve(n==null?void 0:n(u))});return{error:i.error,isLoading:i.isLoading,isSuccess:i.isSuccess,sendTokens:i.mutate,sendTokensAsync:i.mutateAsync,status:i.status}},an=({onError:e,onLoading:t,onSuccess:n}={})=>{let{data:r}=d(),s=r==null?void 0:r.bech32Address,i=(0,y.useMutation)(["USE_SEND_IBC_TOKENS",e,t,n,s],u=>X({senderAddress:s,...u}),{onError:(u,p)=>Promise.resolve(e==null?void 0:e(u,p)),onMutate:t,onSuccess:u=>Promise.resolve(n==null?void 0:n(u))});return{error:i.error,isLoading:i.isLoading,isSuccess:i.isSuccess,sendIbcTokens:i.mutate,sendIbcTokensAsync:i.mutateAsync,status:i.status}},cn=({codeId:e,onError:t,onLoading:n,onSuccess:r})=>{let{data:s}=d(),o=s==null?void 0:s.bech32Address,p=(0,y.useMutation)(["USE_INSTANTIATE_CONTRACT",t,n,r,e,o],m=>{if(!o)throw new Error("senderAddress is undefined");let l={...m,fee:m.fee??"auto",senderAddress:o,codeId:e};return Z(l)},{onError:(m,l)=>Promise.resolve(t==null?void 0:t(m,l)),onMutate:n,onSuccess:m=>Promise.resolve(r==null?void 0:r(m))});return{error:p.error,isLoading:p.isLoading,isSuccess:p.isSuccess,instantiateContract:p.mutate,instantiateContractAsync:p.mutateAsync,status:p.status}},un=({contractAddress:e,onError:t,onLoading:n,onSuccess:r})=>{let{data:s}=d(),o=s==null?void 0:s.bech32Address,p=(0,y.useMutation)(["USE_EXECUTE_CONTRACT",t,n,r,e,o],m=>{if(!o)throw new Error("senderAddress is undefined");let l={...m,fee:m.fee??"auto",senderAddress:o,contractAddress:e};return ee(l)},{onError:(m,l)=>Promise.resolve(t==null?void 0:t(m,l)),onMutate:n,onSuccess:m=>Promise.resolve(r==null?void 0:r(m))});return{error:p.error,isLoading:p.isLoading,isSuccess:p.isSuccess,executeContract:p.mutate,executeContractAsync:p.mutateAsync,status:p.status}},pn=(e,t)=>(0,y.useQuery)(["USE_QUERY_SMART",e,t],({queryKey:[,s]})=>{if(!e||!t)throw new Error("address or queryMsg undefined");return te(e,t)},{enabled:Boolean(e)&&Boolean(t)}),mn=(e,t)=>(0,y.useQuery)(["USE_QUERY_RAW",t,e],({queryKey:[,s]})=>{if(!e||!t)throw new Error("address or key undefined");return ne(e,t)},{enabled:Boolean(e)&&Boolean(t)});var q=require("@tanstack/react-query");var et=require("react");var tt=()=>((0,et.useEffect)(()=>{let{_reconnect:e}=a.getState();return e&&C(),window.addEventListener("keplr_keystorechange",C),()=>{window.removeEventListener("keplr_keystorechange",C)}},[]),null),de=()=>(tt(),null);var ye=require("react/jsx-runtime"),ln=new q.QueryClient({}),gn=({children:e,grazOptions:t,...n})=>(t&&F(t),(0,ye.jsxs)(q.QueryClientProvider,{client:ln,...n,children:[(0,ye.jsx)(de,{}),e]}));0&&(module.exports={GrazEvents,GrazProvider,WALLET_TYPES,WalletType,checkWallet,clearRecentChain,configureGraz,connect,createClients,createQueryClient,createSigningClients,defineChain,defineChainInfo,defineChains,disconnect,executeContract,getActiveChainCurrency,getAddressesByIbcDomain,getAvailableWallets,getBalanceStaked,getBalances,getChainAddressByIbcDomain,getIbcDomainByAdress,getIbcDomainDetails,getKeplr,getLeap,getQueryRaw,getQuerySmart,getRecentChain,getWallet,instantiateContract,isIbcDomainPostfix,mainnetChains,mainnetChainsArray,reconnect,resolveToChainAddress,sendIbcTokens,sendTokens,suggestChain,suggestChainAndConnect,testnetChains,testnetChainsArray,useAccount,useActiveChain,useActiveChainCurrency,useActiveChainValidators,useAddressToIbcDomain,useBalance,useBalanceStaked,useBalances,useCheckKeplr,useCheckWallet,useClients,useConnect,useDisconnect,useExecuteContract,useGrazEvents,useIbcDomainDetails,useIbcDomainToAddresses,useIbcDomainToChainAddress,useInstantiateContract,useOfflineSigners,useQueryClient,useQueryRaw,useQuerySmart,useRecentChain,useResolveToChainAddress,useSendIbcTokens,useSendTokens,useSigners,useSigningClients,useSuggestChain,useSuggestChainAndConnect,validateAddress});
